##################################################
## Project: C19 dynamic graph analysis
## Script purpose: common constants and functions
## Author: Filipp Shelobolin
##################################################

# Libraries ---------------------------------------------------------------

library(tidyverse)
library(here)
library(lubridate)
library(plyr)
### Function renaming in response to plyr masking
mutate <- dplyr::mutate
summarize <- dplyr::summarize
rename <- dplyr::rename

# Constants ---------------------------------------------------------------
cat("Loading constants... "); flush.console()

start_date <- as.Date("01-01-2020", format = "%m-%d-%Y")
end_date <- as.Date("08-01-2020", format = "%m-%d-%Y")
month_seq <- seq.Date(from = start_date, to = end_date, by = "month")
day_seq <- seq.Date(from = start_date, to = end_date, by = "day")
### How many different files to write (increase if running into RAM limitations)
### Set to 10 to adhere to GitHub's maximum file size.
passenger_flow_file_count <- 10
nodes_global_file_count <- 5
nodes_usa_file_count <- 5

cat("Done.\n"); flush.console()
# Functions ---------------------------------------------------------------
cat("Loading functions... "); flush.console()

## Input: (1) R object (2) char name
## Output: NULL
## Purpose: Save object to .Rds file under /Rds with given name.
save_object <- function(x, object_name) {
  saveRDS(x, paste("Rds/",
    paste(object_name, ".Rds", sep = ""),
    sep = ""
    ) %>%
      iconv ### Fixes some weird UTF-8 bugs.
  )
}

## Input: (1) dataframe with columns "Prediction" and "date"
## Output: vector of disaggregated daily predictions ranging from start_date to end_date (constants)
## Purpose: Create vector of disaggregated values for parse_origin_dest_dta function
disaggregate <- function(x) {
  x_sub <- x %>%
    ungroup %>%
    select(date, "Prediction") %>%
    dplyr::rename(
      value = Prediction,
      time = date
    )
  disaggregation <- td(x_sub ~ 1, to = "daily", method = "fast") %>%
    predict()
  disaggregation <- disaggregation[which(disaggregation$time %in% day_seq), ]
  value <- disaggregation$value %>%
    floor
  negative_values <- which(value < 0)
  value[negative_values] <- rep(0, length(negative_values))
  return(value)
}


## Input: (1) dataframe with "origin" (and similar), "destination" (and similar), "date", and "Prediction" columns
##        s.t. only one unique origin/destination pair (should be subset of passenger flow data)
## Output: Same dataframe disaggregated to daily estimates.
## Purpose: use "disaggregate" function to create modified dataframe
parse_origin_dest_dta <- function(y) {
  y <- distinct(y, date, .keep_all = TRUE) %>%
    ungroup() %>%
    select(origin_ID, dest_ID, ID, Prediction, date)
  y <- y[which(y$date %in% month_seq), ]
  if (length(y$date) < length(month_seq)) {
    dates_remaining <- month_seq[!month_seq %in% y$date] %>%
      as.Date(origin="1970-01-01")
    n <- length(dates_remaining)
    y_add <- data.frame(
      origin_ID = rep(y$origin_ID[1], n),
      dest_ID = rep(y$dest_ID[1], n),
      ID = rep(y$ID[1], n),
      Prediction = rep(0, n),
      date = dates_remaining
    )
    assertthat::are_equal(names(y), names(y_add))
    y <- rbind(y, y_add) %>%
      dplyr::arrange(date)
  }
  num_days <- length(day_seq)
  disaggregated_y <- data.frame(
    origin_ID = rep(y$origin_ID[1], num_days),
    dest_ID = rep(y$dest_ID[1], num_days),
    ID = rep(y$ID[1], num_days),
    Prediction = disaggregate(y),
    date = day_seq
  )
  return(disaggregated_y)
}

### Disaggregates data and saves to to K .csv files. Decreases RAM usage.
## Input: (1) air flow data (data.frame generated by files 11/12 from source)
##        (2) folder to write to (char)
##        (3) number of files to write (integer)
disaggregate_in_parts <- function(dta, folder, K) {
  breaks <- seq(1, nrow(dta), length.out = K + 1) %>% floor
  breaks[length(breaks)] <- breaks[length(breaks)] + 1
  lapply(1:K, function(k) {
    w_subset <- breaks[k]:(breaks[k+1] - 1)
    dta_subset <- dta[w_subset, ]
    disaggregated <- split(dta_subset, dta_subset$ID) %>%
      lapply(., parse_origin_dest_dta) %>%
      rbind.fill
    write.csv(
      disaggregated,
      paste(folder, 
            paste(as.character(k), ".csv", sep = ""),
            sep = "")
    )
    rm(disaggregated)
    rm(dta_subset)
    cat("Disaggregation iteration ", k, "done\n"); flush.console()
  })
}

## Input: (1) Vector of airport codes (char)
##        (2) col_type %in% c("Origin", "Dest")
##        (3) airport_codes lookup table
## Output: data.frame(country_name, sub_region_1)
## Purpose: match airport codes to their location data
airport_country_matcher <- function(airports, col_type, airport_codes) {
  n = length(airports)
  if (col_type == "Origin") {
    countries <- data.frame(
      origin_country_name = rep(NA, n),
      origin_sub_region_1 = rep(NA, n)
    )
  } else if (col_type == "Dest") {
    countries <- data.frame(
      dest_country_name = rep(NA, n),
      dest_sub_region_1 = rep(NA, n)
    )
  }
  lapply(unique(airports), function(x) {
    w_in_airports <- which(airports == x)
    w_in_airport_codes <- which(airport_codes$airport_code == x)
    country <- airport_codes[w_in_airport_codes, 2:3]
    if (nrow(country) == 0) {
      return()
    }
    countries[w_in_airports, ] <<- country
  })
  return(countries)
}

## Input: FIPS code of class integer
## Output: FIPS code of class char
FIPS_converter <- function(x) {
  if (is.na(x)) {
    return(NA)
  }
  zeros_needed <- 5 - nchar(x) ### Every FIPS value should have 5 characters.
  zeros <- paste(rep("0", zeros_needed), collapse = "")
  return(paste(zeros, x, sep = ""))
}

## Input: (1) row of passenger flow data
##        (2) FIPS column name
##        (3) sub_region_1 column name
##        (4) country_name column name
## Output: Unique ID (char)
make_node_ID <- function(x, sub_region_1_name, country_name_name) {
  if (sum(c(sub_region_1_name, country_name_name) %in% names(x)) < 2) {
    stop("make_node_ID: given column names not found in x.")
  }
  sub_region_1_col <- x[[sub_region_1_name]]
  country_name_col <- x[[country_name_name]]
  paste(
    sub_region_1_col,
    country_name_col,
    sep = ", "
  ) %>%
    return
}

## Input: (1) row containing origin_ID and dest_ID columns
## Output: unique edge ID (char)
make_edge_ID <- function(x) {
  if (sum(c("origin_ID", "dest_ID") %in% names(x)) < 2) {
    stop("make_edge_ID: x does not have origin_ID or dest_ID columns.")
  }
  paste(x$origin_ID, x$dest_ID, sep="-")
}

## Input: NULL
## Output: NULL
## Purpose: exit a script without an error
stop_quietly <- function() {
  opt <- options(show.error.messages = FALSE)
  on.exit(options(opt))
  stop()
}

cat("Done.\n"); flush.console()